// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i homework-1/internal/repository/order.OrderInterface -o order_interface_mock.go -n OrderInterfaceMock -p mock

import (
	"context"
	"homework-1/loms/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderInterfaceMock implements mm_order.OrderInterface
type OrderInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userID int64, items []model.OrderItem) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, userID int64, items []model.OrderItem)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderInterfaceMockCreate

	funcGetByID          func(ctx context.Context, orderID int64) (s1 string, i1 int64, oa1 []model.OrderItem, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, orderID int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mOrderInterfaceMockGetByID

	funcSetStatus          func(ctx context.Context, orderID int64, status string) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, orderID int64, status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderInterfaceMockSetStatus
}

// NewOrderInterfaceMock returns a mock for mm_order.OrderInterface
func NewOrderInterfaceMock(t minimock.Tester) *OrderInterfaceMock {
	m := &OrderInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderInterfaceMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderInterfaceMockCreateParams{}

	m.GetByIDMock = mOrderInterfaceMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*OrderInterfaceMockGetByIDParams{}

	m.SetStatusMock = mOrderInterfaceMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderInterfaceMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderInterfaceMockCreate struct {
	optional           bool
	mock               *OrderInterfaceMock
	defaultExpectation *OrderInterfaceMockCreateExpectation
	expectations       []*OrderInterfaceMockCreateExpectation

	callArgs []*OrderInterfaceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderInterfaceMockCreateExpectation specifies expectation struct of the OrderInterface.Create
type OrderInterfaceMockCreateExpectation struct {
	mock               *OrderInterfaceMock
	params             *OrderInterfaceMockCreateParams
	paramPtrs          *OrderInterfaceMockCreateParamPtrs
	expectationOrigins OrderInterfaceMockCreateExpectationOrigins
	results            *OrderInterfaceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrderInterfaceMockCreateParams contains parameters of the OrderInterface.Create
type OrderInterfaceMockCreateParams struct {
	ctx    context.Context
	userID int64
	items  []model.OrderItem
}

// OrderInterfaceMockCreateParamPtrs contains pointers to parameters of the OrderInterface.Create
type OrderInterfaceMockCreateParamPtrs struct {
	ctx    *context.Context
	userID *int64
	items  *[]model.OrderItem
}

// OrderInterfaceMockCreateResults contains results of the OrderInterface.Create
type OrderInterfaceMockCreateResults struct {
	i1  int64
	err error
}

// OrderInterfaceMockCreateOrigins contains origins of expectations of the OrderInterface.Create
type OrderInterfaceMockCreateExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItems  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderInterfaceMockCreate) Optional() *mOrderInterfaceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) Expect(ctx context.Context, userID int64, items []model.OrderItem) *mOrderInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderInterfaceMockCreateParams{ctx, userID, items}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserIDParam2 sets up expected param userID for OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) ExpectUserIDParam2(userID int64) *mOrderInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userID = &userID
	mmCreate.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectItemsParam3 sets up expected param items for OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) ExpectItemsParam3(items []model.OrderItem) *mOrderInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.items = &items
	mmCreate.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) Inspect(f func(ctx context.Context, userID int64, items []model.OrderItem)) *mOrderInterfaceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderInterfaceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderInterface.Create
func (mmCreate *mOrderInterfaceMockCreate) Return(i1 int64, err error) *OrderInterfaceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderInterfaceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderInterfaceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OrderInterface.Create method
func (mmCreate *mOrderInterfaceMockCreate) Set(f func(ctx context.Context, userID int64, items []model.OrderItem) (i1 int64, err error)) *OrderInterfaceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderInterface.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderInterface.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OrderInterface.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderInterfaceMockCreate) When(ctx context.Context, userID int64, items []model.OrderItem) *OrderInterfaceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderInterfaceMock.Create mock is already set by Set")
	}

	expectation := &OrderInterfaceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrderInterfaceMockCreateParams{ctx, userID, items},
		expectationOrigins: OrderInterfaceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderInterface.Create return parameters for the expectation previously defined by the When method
func (e *OrderInterfaceMockCreateExpectation) Then(i1 int64, err error) *OrderInterfaceMock {
	e.results = &OrderInterfaceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times OrderInterface.Create should be invoked
func (mmCreate *mOrderInterfaceMockCreate) Times(n uint64) *mOrderInterfaceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderInterfaceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrderInterfaceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_order.OrderInterface
func (mmCreate *OrderInterfaceMock) Create(ctx context.Context, userID int64, items []model.OrderItem) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userID, items)
	}

	mm_params := OrderInterfaceMockCreateParams{ctx, userID, items}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderInterfaceMockCreateParams{ctx, userID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderInterfaceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreate.t.Errorf("OrderInterfaceMock.Create got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreate.t.Errorf("OrderInterfaceMock.Create got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderInterfaceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderInterfaceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userID, items)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderInterfaceMock.Create. %v %v %v", ctx, userID, items)
	return
}

// CreateAfterCounter returns a count of finished OrderInterfaceMock.Create invocations
func (mmCreate *OrderInterfaceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderInterfaceMock.Create invocations
func (mmCreate *OrderInterfaceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderInterfaceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderInterfaceMockCreate) Calls() []*OrderInterfaceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderInterfaceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderInterfaceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderInterfaceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderInterfaceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderInterfaceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderInterfaceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrderInterfaceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderInterfaceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrderInterfaceMockGetByID struct {
	optional           bool
	mock               *OrderInterfaceMock
	defaultExpectation *OrderInterfaceMockGetByIDExpectation
	expectations       []*OrderInterfaceMockGetByIDExpectation

	callArgs []*OrderInterfaceMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderInterfaceMockGetByIDExpectation specifies expectation struct of the OrderInterface.GetByID
type OrderInterfaceMockGetByIDExpectation struct {
	mock               *OrderInterfaceMock
	params             *OrderInterfaceMockGetByIDParams
	paramPtrs          *OrderInterfaceMockGetByIDParamPtrs
	expectationOrigins OrderInterfaceMockGetByIDExpectationOrigins
	results            *OrderInterfaceMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderInterfaceMockGetByIDParams contains parameters of the OrderInterface.GetByID
type OrderInterfaceMockGetByIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderInterfaceMockGetByIDParamPtrs contains pointers to parameters of the OrderInterface.GetByID
type OrderInterfaceMockGetByIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderInterfaceMockGetByIDResults contains results of the OrderInterface.GetByID
type OrderInterfaceMockGetByIDResults struct {
	s1  string
	i1  int64
	oa1 []model.OrderItem
	err error
}

// OrderInterfaceMockGetByIDOrigins contains origins of expectations of the OrderInterface.GetByID
type OrderInterfaceMockGetByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mOrderInterfaceMockGetByID) Optional() *mOrderInterfaceMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for OrderInterface.GetByID
func (mmGetByID *mOrderInterfaceMockGetByID) Expect(ctx context.Context, orderID int64) *mOrderInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &OrderInterfaceMockGetByIDParams{ctx, orderID}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderInterface.GetByID
func (mmGetByID *mOrderInterfaceMockGetByID) ExpectCtxParam1(ctx context.Context) *mOrderInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrderInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderInterface.GetByID
func (mmGetByID *mOrderInterfaceMockGetByID) ExpectOrderIDParam2(orderID int64) *mOrderInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrderInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the OrderInterface.GetByID
func (mmGetByID *mOrderInterfaceMockGetByID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderInterfaceMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for OrderInterfaceMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by OrderInterface.GetByID
func (mmGetByID *mOrderInterfaceMockGetByID) Return(s1 string, i1 int64, oa1 []model.OrderItem, err error) *OrderInterfaceMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderInterfaceMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &OrderInterfaceMockGetByIDResults{s1, i1, oa1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the OrderInterface.GetByID method
func (mmGetByID *mOrderInterfaceMockGetByID) Set(f func(ctx context.Context, orderID int64) (s1 string, i1 int64, oa1 []model.OrderItem, err error)) *OrderInterfaceMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the OrderInterface.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the OrderInterface.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the OrderInterface.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mOrderInterfaceMockGetByID) When(ctx context.Context, orderID int64) *OrderInterfaceMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderInterfaceMock.GetByID mock is already set by Set")
	}

	expectation := &OrderInterfaceMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &OrderInterfaceMockGetByIDParams{ctx, orderID},
		expectationOrigins: OrderInterfaceMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up OrderInterface.GetByID return parameters for the expectation previously defined by the When method
func (e *OrderInterfaceMockGetByIDExpectation) Then(s1 string, i1 int64, oa1 []model.OrderItem, err error) *OrderInterfaceMock {
	e.results = &OrderInterfaceMockGetByIDResults{s1, i1, oa1, err}
	return e.mock
}

// Times sets number of times OrderInterface.GetByID should be invoked
func (mmGetByID *mOrderInterfaceMockGetByID) Times(n uint64) *mOrderInterfaceMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of OrderInterfaceMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mOrderInterfaceMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_order.OrderInterface
func (mmGetByID *OrderInterfaceMock) GetByID(ctx context.Context, orderID int64) (s1 string, i1 int64, oa1 []model.OrderItem, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, orderID)
	}

	mm_params := OrderInterfaceMockGetByIDParams{ctx, orderID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.i1, e.results.oa1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderInterfaceMockGetByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("OrderInterfaceMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByID.t.Errorf("OrderInterfaceMock.GetByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("OrderInterfaceMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the OrderInterfaceMock.GetByID")
		}
		return (*mm_results).s1, (*mm_results).i1, (*mm_results).oa1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, orderID)
	}
	mmGetByID.t.Fatalf("Unexpected call to OrderInterfaceMock.GetByID. %v %v", ctx, orderID)
	return
}

// GetByIDAfterCounter returns a count of finished OrderInterfaceMock.GetByID invocations
func (mmGetByID *OrderInterfaceMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of OrderInterfaceMock.GetByID invocations
func (mmGetByID *OrderInterfaceMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderInterfaceMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mOrderInterfaceMockGetByID) Calls() []*OrderInterfaceMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*OrderInterfaceMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *OrderInterfaceMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *OrderInterfaceMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderInterfaceMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderInterfaceMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderInterfaceMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderInterfaceMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderInterfaceMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mOrderInterfaceMockSetStatus struct {
	optional           bool
	mock               *OrderInterfaceMock
	defaultExpectation *OrderInterfaceMockSetStatusExpectation
	expectations       []*OrderInterfaceMockSetStatusExpectation

	callArgs []*OrderInterfaceMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderInterfaceMockSetStatusExpectation specifies expectation struct of the OrderInterface.SetStatus
type OrderInterfaceMockSetStatusExpectation struct {
	mock               *OrderInterfaceMock
	params             *OrderInterfaceMockSetStatusParams
	paramPtrs          *OrderInterfaceMockSetStatusParamPtrs
	expectationOrigins OrderInterfaceMockSetStatusExpectationOrigins
	results            *OrderInterfaceMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrderInterfaceMockSetStatusParams contains parameters of the OrderInterface.SetStatus
type OrderInterfaceMockSetStatusParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// OrderInterfaceMockSetStatusParamPtrs contains pointers to parameters of the OrderInterface.SetStatus
type OrderInterfaceMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *string
}

// OrderInterfaceMockSetStatusResults contains results of the OrderInterface.SetStatus
type OrderInterfaceMockSetStatusResults struct {
	err error
}

// OrderInterfaceMockSetStatusOrigins contains origins of expectations of the OrderInterface.SetStatus
type OrderInterfaceMockSetStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderInterfaceMockSetStatus) Optional() *mOrderInterfaceMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) Expect(ctx context.Context, orderID int64, status string) *mOrderInterfaceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderInterfaceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderInterfaceMockSetStatusParams{ctx, orderID, status}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderInterfaceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderInterfaceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderInterfaceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) ExpectOrderIDParam2(orderID int64) *mOrderInterfaceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderInterfaceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderInterfaceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) ExpectStatusParam3(status string) *mOrderInterfaceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderInterfaceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderInterfaceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status
	mmSetStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) Inspect(f func(ctx context.Context, orderID int64, status string)) *mOrderInterfaceMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderInterfaceMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderInterface.SetStatus
func (mmSetStatus *mOrderInterfaceMockSetStatus) Return(err error) *OrderInterfaceMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderInterfaceMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderInterfaceMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderInterface.SetStatus method
func (mmSetStatus *mOrderInterfaceMockSetStatus) Set(f func(ctx context.Context, orderID int64, status string) (err error)) *OrderInterfaceMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderInterface.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderInterface.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the OrderInterface.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderInterfaceMockSetStatus) When(ctx context.Context, orderID int64, status string) *OrderInterfaceMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderInterfaceMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderInterfaceMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &OrderInterfaceMockSetStatusParams{ctx, orderID, status},
		expectationOrigins: OrderInterfaceMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderInterface.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderInterfaceMockSetStatusExpectation) Then(err error) *OrderInterfaceMock {
	e.results = &OrderInterfaceMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrderInterface.SetStatus should be invoked
func (mmSetStatus *mOrderInterfaceMockSetStatus) Times(n uint64) *mOrderInterfaceMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderInterfaceMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mOrderInterfaceMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_order.OrderInterface
func (mmSetStatus *OrderInterfaceMock) SetStatus(ctx context.Context, orderID int64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderInterfaceMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderInterfaceMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderInterfaceMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrderInterfaceMock.SetStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderInterfaceMock.SetStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderInterfaceMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderInterfaceMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderInterfaceMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderInterfaceMock.SetStatus invocations
func (mmSetStatus *OrderInterfaceMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderInterfaceMock.SetStatus invocations
func (mmSetStatus *OrderInterfaceMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderInterfaceMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderInterfaceMockSetStatus) Calls() []*OrderInterfaceMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderInterfaceMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderInterfaceMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderInterfaceMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderInterfaceMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderInterfaceMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderInterfaceMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to OrderInterfaceMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderInterfaceMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIDInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockSetStatusDone()
}
