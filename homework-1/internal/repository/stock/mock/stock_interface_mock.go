// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i homework-1/internal/repository/stock.StockInterface -o stock_interface_mock.go -n StockInterfaceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockInterfaceMock implements mm_stock.StockInterface
type StockInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, sku uint32) (u1 uint16, err error)
	funcGetBySKUOrigin    string
	inspectFuncGetBySKU   func(ctx context.Context, sku uint32)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mStockInterfaceMockGetBySKU

	funcReserve          func(ctx context.Context, sku uint32, count uint16) (b1 bool)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, sku uint32, count uint16)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockInterfaceMockReserve

	funcReserveCancel          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveCancelOrigin    string
	inspectFuncReserveCancel   func(ctx context.Context, sku uint32, count uint16)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStockInterfaceMockReserveCancel

	funcReserveRemove          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, sku uint32, count uint16)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockInterfaceMockReserveRemove
}

// NewStockInterfaceMock returns a mock for mm_stock.StockInterface
func NewStockInterfaceMock(t minimock.Tester) *StockInterfaceMock {
	m := &StockInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mStockInterfaceMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*StockInterfaceMockGetBySKUParams{}

	m.ReserveMock = mStockInterfaceMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockInterfaceMockReserveParams{}

	m.ReserveCancelMock = mStockInterfaceMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StockInterfaceMockReserveCancelParams{}

	m.ReserveRemoveMock = mStockInterfaceMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockInterfaceMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockInterfaceMockGetBySKU struct {
	optional           bool
	mock               *StockInterfaceMock
	defaultExpectation *StockInterfaceMockGetBySKUExpectation
	expectations       []*StockInterfaceMockGetBySKUExpectation

	callArgs []*StockInterfaceMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockInterfaceMockGetBySKUExpectation specifies expectation struct of the StockInterface.GetBySKU
type StockInterfaceMockGetBySKUExpectation struct {
	mock               *StockInterfaceMock
	params             *StockInterfaceMockGetBySKUParams
	paramPtrs          *StockInterfaceMockGetBySKUParamPtrs
	expectationOrigins StockInterfaceMockGetBySKUExpectationOrigins
	results            *StockInterfaceMockGetBySKUResults
	returnOrigin       string
	Counter            uint64
}

// StockInterfaceMockGetBySKUParams contains parameters of the StockInterface.GetBySKU
type StockInterfaceMockGetBySKUParams struct {
	ctx context.Context
	sku uint32
}

// StockInterfaceMockGetBySKUParamPtrs contains pointers to parameters of the StockInterface.GetBySKU
type StockInterfaceMockGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *uint32
}

// StockInterfaceMockGetBySKUResults contains results of the StockInterface.GetBySKU
type StockInterfaceMockGetBySKUResults struct {
	u1  uint16
	err error
}

// StockInterfaceMockGetBySKUOrigins contains origins of expectations of the StockInterface.GetBySKU
type StockInterfaceMockGetBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Optional() *mStockInterfaceMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for StockInterface.GetBySKU
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Expect(ctx context.Context, sku uint32) *mStockInterfaceMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockInterfaceMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &StockInterfaceMockGetBySKUParams{ctx, sku}
	mmGetBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StockInterface.GetBySKU
func (mmGetBySKU *mStockInterfaceMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mStockInterfaceMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockInterfaceMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockInterfaceMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for StockInterface.GetBySKU
func (mmGetBySKU *mStockInterfaceMockGetBySKU) ExpectSkuParam2(sku uint32) *mStockInterfaceMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockInterfaceMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockInterfaceMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the StockInterface.GetBySKU
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Inspect(f func(ctx context.Context, sku uint32)) *mStockInterfaceMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for StockInterfaceMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by StockInterface.GetBySKU
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Return(u1 uint16, err error) *StockInterfaceMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockInterfaceMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &StockInterfaceMockGetBySKUResults{u1, err}
	mmGetBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// Set uses given function f to mock the StockInterface.GetBySKU method
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Set(f func(ctx context.Context, sku uint32) (u1 uint16, err error)) *StockInterfaceMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the StockInterface.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the StockInterface.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	mmGetBySKU.mock.funcGetBySKUOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// When sets expectation for the StockInterface.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mStockInterfaceMockGetBySKU) When(ctx context.Context, sku uint32) *StockInterfaceMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockInterfaceMock.GetBySKU mock is already set by Set")
	}

	expectation := &StockInterfaceMockGetBySKUExpectation{
		mock:               mmGetBySKU.mock,
		params:             &StockInterfaceMockGetBySKUParams{ctx, sku},
		expectationOrigins: StockInterfaceMockGetBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up StockInterface.GetBySKU return parameters for the expectation previously defined by the When method
func (e *StockInterfaceMockGetBySKUExpectation) Then(u1 uint16, err error) *StockInterfaceMock {
	e.results = &StockInterfaceMockGetBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times StockInterface.GetBySKU should be invoked
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Times(n uint64) *mStockInterfaceMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of StockInterfaceMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	mmGetBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySKU
}

func (mmGetBySKU *mStockInterfaceMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements mm_stock.StockInterface
func (mmGetBySKU *StockInterfaceMock) GetBySKU(ctx context.Context, sku uint32) (u1 uint16, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	mmGetBySKU.t.Helper()

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, sku)
	}

	mm_params := StockInterfaceMockGetBySKUParams{ctx, sku}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StockInterfaceMockGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("StockInterfaceMock.GetBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetBySKU.t.Errorf("StockInterfaceMock.GetBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("StockInterfaceMock.GetBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the StockInterfaceMock.GetBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, sku)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to StockInterfaceMock.GetBySKU. %v %v", ctx, sku)
	return
}

// GetBySKUAfterCounter returns a count of finished StockInterfaceMock.GetBySKU invocations
func (mmGetBySKU *StockInterfaceMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of StockInterfaceMock.GetBySKU invocations
func (mmGetBySKU *StockInterfaceMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StockInterfaceMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mStockInterfaceMockGetBySKU) Calls() []*StockInterfaceMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*StockInterfaceMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *StockInterfaceMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *StockInterfaceMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockInterfaceMock.GetBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockInterfaceMock.GetBySKU at\n%s", m.GetBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockInterfaceMock.GetBySKU at\n%s with params: %#v", m.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Errorf("Expected call to StockInterfaceMock.GetBySKU at\n%s", m.funcGetBySKUOrigin)
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StockInterfaceMock.GetBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), m.GetBySKUMock.expectedInvocationsOrigin, afterGetBySKUCounter)
	}
}

type mStockInterfaceMockReserve struct {
	optional           bool
	mock               *StockInterfaceMock
	defaultExpectation *StockInterfaceMockReserveExpectation
	expectations       []*StockInterfaceMockReserveExpectation

	callArgs []*StockInterfaceMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockInterfaceMockReserveExpectation specifies expectation struct of the StockInterface.Reserve
type StockInterfaceMockReserveExpectation struct {
	mock               *StockInterfaceMock
	params             *StockInterfaceMockReserveParams
	paramPtrs          *StockInterfaceMockReserveParamPtrs
	expectationOrigins StockInterfaceMockReserveExpectationOrigins
	results            *StockInterfaceMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// StockInterfaceMockReserveParams contains parameters of the StockInterface.Reserve
type StockInterfaceMockReserveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockInterfaceMockReserveParamPtrs contains pointers to parameters of the StockInterface.Reserve
type StockInterfaceMockReserveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockInterfaceMockReserveResults contains results of the StockInterface.Reserve
type StockInterfaceMockReserveResults struct {
	b1 bool
}

// StockInterfaceMockReserveOrigins contains origins of expectations of the StockInterface.Reserve
type StockInterfaceMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockInterfaceMockReserve) Optional() *mStockInterfaceMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) Expect(ctx context.Context, sku uint32, count uint16) *mStockInterfaceMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockInterfaceMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockInterfaceMockReserveParams{ctx, sku, count}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) ExpectCtxParam1(ctx context.Context) *mStockInterfaceMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockInterfaceMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockInterfaceMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectSkuParam2 sets up expected param sku for StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) ExpectSkuParam2(sku uint32) *mStockInterfaceMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockInterfaceMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockInterfaceMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.sku = &sku
	mmReserve.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectCountParam3 sets up expected param count for StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) ExpectCountParam3(count uint16) *mStockInterfaceMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockInterfaceMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockInterfaceMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.count = &count
	mmReserve.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockInterfaceMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockInterfaceMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StockInterface.Reserve
func (mmReserve *mStockInterfaceMockReserve) Return(b1 bool) *StockInterfaceMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockInterfaceMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockInterfaceMockReserveResults{b1}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the StockInterface.Reserve method
func (mmReserve *mStockInterfaceMockReserve) Set(f func(ctx context.Context, sku uint32, count uint16) (b1 bool)) *StockInterfaceMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StockInterface.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StockInterface.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the StockInterface.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockInterfaceMockReserve) When(ctx context.Context, sku uint32, count uint16) *StockInterfaceMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockInterfaceMock.Reserve mock is already set by Set")
	}

	expectation := &StockInterfaceMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &StockInterfaceMockReserveParams{ctx, sku, count},
		expectationOrigins: StockInterfaceMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StockInterface.Reserve return parameters for the expectation previously defined by the When method
func (e *StockInterfaceMockReserveExpectation) Then(b1 bool) *StockInterfaceMock {
	e.results = &StockInterfaceMockReserveResults{b1}
	return e.mock
}

// Times sets number of times StockInterface.Reserve should be invoked
func (mmReserve *mStockInterfaceMockReserve) Times(n uint64) *mStockInterfaceMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockInterfaceMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mStockInterfaceMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_stock.StockInterface
func (mmReserve *StockInterfaceMock) Reserve(ctx context.Context, sku uint32, count uint16) (b1 bool) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, sku, count)
	}

	mm_params := StockInterfaceMockReserveParams{ctx, sku, count}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockInterfaceMockReserveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockInterfaceMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserve.t.Errorf("StockInterfaceMock.Reserve got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserve.t.Errorf("StockInterfaceMock.Reserve got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockInterfaceMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockInterfaceMock.Reserve")
		}
		return (*mm_results).b1
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, sku, count)
	}
	mmReserve.t.Fatalf("Unexpected call to StockInterfaceMock.Reserve. %v %v %v", ctx, sku, count)
	return
}

// ReserveAfterCounter returns a count of finished StockInterfaceMock.Reserve invocations
func (mmReserve *StockInterfaceMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockInterfaceMock.Reserve invocations
func (mmReserve *StockInterfaceMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockInterfaceMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockInterfaceMockReserve) Calls() []*StockInterfaceMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockInterfaceMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockInterfaceMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockInterfaceMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockInterfaceMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockInterfaceMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockInterfaceMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to StockInterfaceMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockInterfaceMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mStockInterfaceMockReserveCancel struct {
	optional           bool
	mock               *StockInterfaceMock
	defaultExpectation *StockInterfaceMockReserveCancelExpectation
	expectations       []*StockInterfaceMockReserveCancelExpectation

	callArgs []*StockInterfaceMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockInterfaceMockReserveCancelExpectation specifies expectation struct of the StockInterface.ReserveCancel
type StockInterfaceMockReserveCancelExpectation struct {
	mock               *StockInterfaceMock
	params             *StockInterfaceMockReserveCancelParams
	paramPtrs          *StockInterfaceMockReserveCancelParamPtrs
	expectationOrigins StockInterfaceMockReserveCancelExpectationOrigins
	results            *StockInterfaceMockReserveCancelResults
	returnOrigin       string
	Counter            uint64
}

// StockInterfaceMockReserveCancelParams contains parameters of the StockInterface.ReserveCancel
type StockInterfaceMockReserveCancelParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockInterfaceMockReserveCancelParamPtrs contains pointers to parameters of the StockInterface.ReserveCancel
type StockInterfaceMockReserveCancelParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockInterfaceMockReserveCancelResults contains results of the StockInterface.ReserveCancel
type StockInterfaceMockReserveCancelResults struct {
	err error
}

// StockInterfaceMockReserveCancelOrigins contains origins of expectations of the StockInterface.ReserveCancel
type StockInterfaceMockReserveCancelExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Optional() *mStockInterfaceMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Expect(ctx context.Context, sku uint32, count uint16) *mStockInterfaceMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockInterfaceMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StockInterfaceMockReserveCancelParams{ctx, sku, count}
	mmReserveCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStockInterfaceMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockInterfaceMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockInterfaceMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectSkuParam2 sets up expected param sku for StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) ExpectSkuParam2(sku uint32) *mStockInterfaceMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockInterfaceMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockInterfaceMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.sku = &sku
	mmReserveCancel.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectCountParam3 sets up expected param count for StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) ExpectCountParam3(count uint16) *mStockInterfaceMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockInterfaceMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockInterfaceMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.count = &count
	mmReserveCancel.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockInterfaceMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StockInterfaceMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by StockInterface.ReserveCancel
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Return(err error) *StockInterfaceMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockInterfaceMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StockInterfaceMockReserveCancelResults{err}
	mmReserveCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// Set uses given function f to mock the StockInterface.ReserveCancel method
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *StockInterfaceMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the StockInterface.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the StockInterface.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	mmReserveCancel.mock.funcReserveCancelOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// When sets expectation for the StockInterface.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStockInterfaceMockReserveCancel) When(ctx context.Context, sku uint32, count uint16) *StockInterfaceMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockInterfaceMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StockInterfaceMockReserveCancelExpectation{
		mock:               mmReserveCancel.mock,
		params:             &StockInterfaceMockReserveCancelParams{ctx, sku, count},
		expectationOrigins: StockInterfaceMockReserveCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up StockInterface.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StockInterfaceMockReserveCancelExpectation) Then(err error) *StockInterfaceMock {
	e.results = &StockInterfaceMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times StockInterface.ReserveCancel should be invoked
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Times(n uint64) *mStockInterfaceMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StockInterfaceMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	mmReserveCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancel
}

func (mmReserveCancel *mStockInterfaceMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements mm_stock.StockInterface
func (mmReserveCancel *StockInterfaceMock) ReserveCancel(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	mmReserveCancel.t.Helper()

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, sku, count)
	}

	mm_params := StockInterfaceMockReserveCancelParams{ctx, sku, count}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StockInterfaceMockReserveCancelParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StockInterfaceMock.ReserveCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserveCancel.t.Errorf("StockInterfaceMock.ReserveCancel got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserveCancel.t.Errorf("StockInterfaceMock.ReserveCancel got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StockInterfaceMock.ReserveCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StockInterfaceMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, sku, count)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StockInterfaceMock.ReserveCancel. %v %v %v", ctx, sku, count)
	return
}

// ReserveCancelAfterCounter returns a count of finished StockInterfaceMock.ReserveCancel invocations
func (mmReserveCancel *StockInterfaceMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StockInterfaceMock.ReserveCancel invocations
func (mmReserveCancel *StockInterfaceMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StockInterfaceMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStockInterfaceMockReserveCancel) Calls() []*StockInterfaceMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StockInterfaceMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StockInterfaceMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StockInterfaceMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveCancel at\n%s", m.ReserveCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveCancel at\n%s with params: %#v", m.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Errorf("Expected call to StockInterfaceMock.ReserveCancel at\n%s", m.funcReserveCancelOrigin)
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StockInterfaceMock.ReserveCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), m.ReserveCancelMock.expectedInvocationsOrigin, afterReserveCancelCounter)
	}
}

type mStockInterfaceMockReserveRemove struct {
	optional           bool
	mock               *StockInterfaceMock
	defaultExpectation *StockInterfaceMockReserveRemoveExpectation
	expectations       []*StockInterfaceMockReserveRemoveExpectation

	callArgs []*StockInterfaceMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockInterfaceMockReserveRemoveExpectation specifies expectation struct of the StockInterface.ReserveRemove
type StockInterfaceMockReserveRemoveExpectation struct {
	mock               *StockInterfaceMock
	params             *StockInterfaceMockReserveRemoveParams
	paramPtrs          *StockInterfaceMockReserveRemoveParamPtrs
	expectationOrigins StockInterfaceMockReserveRemoveExpectationOrigins
	results            *StockInterfaceMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// StockInterfaceMockReserveRemoveParams contains parameters of the StockInterface.ReserveRemove
type StockInterfaceMockReserveRemoveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockInterfaceMockReserveRemoveParamPtrs contains pointers to parameters of the StockInterface.ReserveRemove
type StockInterfaceMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockInterfaceMockReserveRemoveResults contains results of the StockInterface.ReserveRemove
type StockInterfaceMockReserveRemoveResults struct {
	err error
}

// StockInterfaceMockReserveRemoveOrigins contains origins of expectations of the StockInterface.ReserveRemove
type StockInterfaceMockReserveRemoveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Optional() *mStockInterfaceMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Expect(ctx context.Context, sku uint32, count uint16) *mStockInterfaceMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockInterfaceMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockInterfaceMockReserveRemoveParams{ctx, sku, count}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockInterfaceMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockInterfaceMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockInterfaceMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectSkuParam2 sets up expected param sku for StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) ExpectSkuParam2(sku uint32) *mStockInterfaceMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockInterfaceMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockInterfaceMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.sku = &sku
	mmReserveRemove.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectCountParam3 sets up expected param count for StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) ExpectCountParam3(count uint16) *mStockInterfaceMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockInterfaceMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockInterfaceMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.count = &count
	mmReserveRemove.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockInterfaceMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockInterfaceMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by StockInterface.ReserveRemove
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Return(err error) *StockInterfaceMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockInterfaceMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockInterfaceMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the StockInterface.ReserveRemove method
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *StockInterfaceMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the StockInterface.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the StockInterface.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the StockInterface.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockInterfaceMockReserveRemove) When(ctx context.Context, sku uint32, count uint16) *StockInterfaceMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockInterfaceMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockInterfaceMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &StockInterfaceMockReserveRemoveParams{ctx, sku, count},
		expectationOrigins: StockInterfaceMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up StockInterface.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockInterfaceMockReserveRemoveExpectation) Then(err error) *StockInterfaceMock {
	e.results = &StockInterfaceMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times StockInterface.ReserveRemove should be invoked
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Times(n uint64) *mStockInterfaceMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockInterfaceMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mStockInterfaceMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_stock.StockInterface
func (mmReserveRemove *StockInterfaceMock) ReserveRemove(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, sku, count)
	}

	mm_params := StockInterfaceMockReserveRemoveParams{ctx, sku, count}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockInterfaceMockReserveRemoveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockInterfaceMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserveRemove.t.Errorf("StockInterfaceMock.ReserveRemove got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserveRemove.t.Errorf("StockInterfaceMock.ReserveRemove got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockInterfaceMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockInterfaceMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, sku, count)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockInterfaceMock.ReserveRemove. %v %v %v", ctx, sku, count)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockInterfaceMock.ReserveRemove invocations
func (mmReserveRemove *StockInterfaceMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockInterfaceMock.ReserveRemove invocations
func (mmReserveRemove *StockInterfaceMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockInterfaceMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockInterfaceMockReserveRemove) Calls() []*StockInterfaceMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockInterfaceMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockInterfaceMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockInterfaceMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockInterfaceMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to StockInterfaceMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockInterfaceMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone()
}
