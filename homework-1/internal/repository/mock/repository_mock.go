// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i homework-1/internal/repository.CartRepository -o repository_mock.go -n CartRepositoryMock -p mock

import (
	"homework-1/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_repository.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCart          func(userID int64, sku uint32, count uint16) (total uint16, existed bool)
	funcAddCartOrigin    string
	inspectFuncAddCart   func(userID int64, sku uint32, count uint16)
	afterAddCartCounter  uint64
	beforeAddCartCounter uint64
	AddCartMock          mCartRepositoryMockAddCart

	funcClearCart          func(userID int64) (err error)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(userID int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcGetCart          func(userID int64) (ia1 []model.ItemCart, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(userID int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart

	funcRemoveCart          func(userID int64, sku uint32) (err error)
	funcRemoveCartOrigin    string
	inspectFuncRemoveCart   func(userID int64, sku uint32)
	afterRemoveCartCounter  uint64
	beforeRemoveCartCounter uint64
	RemoveCartMock          mCartRepositoryMockRemoveCart
}

// NewCartRepositoryMock returns a mock for mm_repository.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCartMock = mCartRepositoryMockAddCart{mock: m}
	m.AddCartMock.callArgs = []*CartRepositoryMockAddCartParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	m.RemoveCartMock = mCartRepositoryMockRemoveCart{mock: m}
	m.RemoveCartMock.callArgs = []*CartRepositoryMockRemoveCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddCartExpectation
	expectations       []*CartRepositoryMockAddCartExpectation

	callArgs []*CartRepositoryMockAddCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddCartExpectation specifies expectation struct of the CartRepository.AddCart
type CartRepositoryMockAddCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddCartParams
	paramPtrs          *CartRepositoryMockAddCartParamPtrs
	expectationOrigins CartRepositoryMockAddCartExpectationOrigins
	results            *CartRepositoryMockAddCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddCartParams contains parameters of the CartRepository.AddCart
type CartRepositoryMockAddCartParams struct {
	userID int64
	sku    uint32
	count  uint16
}

// CartRepositoryMockAddCartParamPtrs contains pointers to parameters of the CartRepository.AddCart
type CartRepositoryMockAddCartParamPtrs struct {
	userID *int64
	sku    *uint32
	count  *uint16
}

// CartRepositoryMockAddCartResults contains results of the CartRepository.AddCart
type CartRepositoryMockAddCartResults struct {
	total   uint16
	existed bool
}

// CartRepositoryMockAddCartOrigins contains origins of expectations of the CartRepository.AddCart
type CartRepositoryMockAddCartExpectationOrigins struct {
	origin       string
	originUserID string
	originSku    string
	originCount  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCart *mCartRepositoryMockAddCart) Optional() *mCartRepositoryMockAddCart {
	mmAddCart.optional = true
	return mmAddCart
}

// Expect sets up expected params for CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) Expect(userID int64, sku uint32, count uint16) *mCartRepositoryMockAddCart {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	if mmAddCart.defaultExpectation == nil {
		mmAddCart.defaultExpectation = &CartRepositoryMockAddCartExpectation{}
	}

	if mmAddCart.defaultExpectation.paramPtrs != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by ExpectParams functions")
	}

	mmAddCart.defaultExpectation.params = &CartRepositoryMockAddCartParams{userID, sku, count}
	mmAddCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCart.expectations {
		if minimock.Equal(e.params, mmAddCart.defaultExpectation.params) {
			mmAddCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCart.defaultExpectation.params)
		}
	}

	return mmAddCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockAddCart {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	if mmAddCart.defaultExpectation == nil {
		mmAddCart.defaultExpectation = &CartRepositoryMockAddCartExpectation{}
	}

	if mmAddCart.defaultExpectation.params != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Expect")
	}

	if mmAddCart.defaultExpectation.paramPtrs == nil {
		mmAddCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddCartParamPtrs{}
	}
	mmAddCart.defaultExpectation.paramPtrs.userID = &userID
	mmAddCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddCart
}

// ExpectSkuParam2 sets up expected param sku for CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) ExpectSkuParam2(sku uint32) *mCartRepositoryMockAddCart {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	if mmAddCart.defaultExpectation == nil {
		mmAddCart.defaultExpectation = &CartRepositoryMockAddCartExpectation{}
	}

	if mmAddCart.defaultExpectation.params != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Expect")
	}

	if mmAddCart.defaultExpectation.paramPtrs == nil {
		mmAddCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddCartParamPtrs{}
	}
	mmAddCart.defaultExpectation.paramPtrs.sku = &sku
	mmAddCart.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmAddCart
}

// ExpectCountParam3 sets up expected param count for CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) ExpectCountParam3(count uint16) *mCartRepositoryMockAddCart {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	if mmAddCart.defaultExpectation == nil {
		mmAddCart.defaultExpectation = &CartRepositoryMockAddCartExpectation{}
	}

	if mmAddCart.defaultExpectation.params != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Expect")
	}

	if mmAddCart.defaultExpectation.paramPtrs == nil {
		mmAddCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddCartParamPtrs{}
	}
	mmAddCart.defaultExpectation.paramPtrs.count = &count
	mmAddCart.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) Inspect(f func(userID int64, sku uint32, count uint16)) *mCartRepositoryMockAddCart {
	if mmAddCart.mock.inspectFuncAddCart != nil {
		mmAddCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddCart")
	}

	mmAddCart.mock.inspectFuncAddCart = f

	return mmAddCart
}

// Return sets up results that will be returned by CartRepository.AddCart
func (mmAddCart *mCartRepositoryMockAddCart) Return(total uint16, existed bool) *CartRepositoryMock {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	if mmAddCart.defaultExpectation == nil {
		mmAddCart.defaultExpectation = &CartRepositoryMockAddCartExpectation{mock: mmAddCart.mock}
	}
	mmAddCart.defaultExpectation.results = &CartRepositoryMockAddCartResults{total, existed}
	mmAddCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCart.mock
}

// Set uses given function f to mock the CartRepository.AddCart method
func (mmAddCart *mCartRepositoryMockAddCart) Set(f func(userID int64, sku uint32, count uint16) (total uint16, existed bool)) *CartRepositoryMock {
	if mmAddCart.defaultExpectation != nil {
		mmAddCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddCart method")
	}

	if len(mmAddCart.expectations) > 0 {
		mmAddCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddCart method")
	}

	mmAddCart.mock.funcAddCart = f
	mmAddCart.mock.funcAddCartOrigin = minimock.CallerInfo(1)
	return mmAddCart.mock
}

// When sets expectation for the CartRepository.AddCart which will trigger the result defined by the following
// Then helper
func (mmAddCart *mCartRepositoryMockAddCart) When(userID int64, sku uint32, count uint16) *CartRepositoryMockAddCartExpectation {
	if mmAddCart.mock.funcAddCart != nil {
		mmAddCart.mock.t.Fatalf("CartRepositoryMock.AddCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddCartExpectation{
		mock:               mmAddCart.mock,
		params:             &CartRepositoryMockAddCartParams{userID, sku, count},
		expectationOrigins: CartRepositoryMockAddCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCart.expectations = append(mmAddCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddCartExpectation) Then(total uint16, existed bool) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddCartResults{total, existed}
	return e.mock
}

// Times sets number of times CartRepository.AddCart should be invoked
func (mmAddCart *mCartRepositoryMockAddCart) Times(n uint64) *mCartRepositoryMockAddCart {
	if n == 0 {
		mmAddCart.mock.t.Fatalf("Times of CartRepositoryMock.AddCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCart.expectedInvocations, n)
	mmAddCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCart
}

func (mmAddCart *mCartRepositoryMockAddCart) invocationsDone() bool {
	if len(mmAddCart.expectations) == 0 && mmAddCart.defaultExpectation == nil && mmAddCart.mock.funcAddCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCart.mock.afterAddCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCart implements mm_repository.CartRepository
func (mmAddCart *CartRepositoryMock) AddCart(userID int64, sku uint32, count uint16) (total uint16, existed bool) {
	mm_atomic.AddUint64(&mmAddCart.beforeAddCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCart.afterAddCartCounter, 1)

	mmAddCart.t.Helper()

	if mmAddCart.inspectFuncAddCart != nil {
		mmAddCart.inspectFuncAddCart(userID, sku, count)
	}

	mm_params := CartRepositoryMockAddCartParams{userID, sku, count}

	// Record call args
	mmAddCart.AddCartMock.mutex.Lock()
	mmAddCart.AddCartMock.callArgs = append(mmAddCart.AddCartMock.callArgs, &mm_params)
	mmAddCart.AddCartMock.mutex.Unlock()

	for _, e := range mmAddCart.AddCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.total, e.results.existed
		}
	}

	if mmAddCart.AddCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCart.AddCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCart.AddCartMock.defaultExpectation.params
		mm_want_ptrs := mmAddCart.AddCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddCartParams{userID, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddCart.t.Errorf("CartRepositoryMock.AddCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCart.AddCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmAddCart.t.Errorf("CartRepositoryMock.AddCart got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCart.AddCartMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddCart.t.Errorf("CartRepositoryMock.AddCart got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCart.AddCartMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCart.t.Errorf("CartRepositoryMock.AddCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCart.AddCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCart.AddCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCart.t.Fatal("No results are set for the CartRepositoryMock.AddCart")
		}
		return (*mm_results).total, (*mm_results).existed
	}
	if mmAddCart.funcAddCart != nil {
		return mmAddCart.funcAddCart(userID, sku, count)
	}
	mmAddCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddCart. %v %v %v", userID, sku, count)
	return
}

// AddCartAfterCounter returns a count of finished CartRepositoryMock.AddCart invocations
func (mmAddCart *CartRepositoryMock) AddCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCart.afterAddCartCounter)
}

// AddCartBeforeCounter returns a count of CartRepositoryMock.AddCart invocations
func (mmAddCart *CartRepositoryMock) AddCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCart.beforeAddCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCart *mCartRepositoryMockAddCart) Calls() []*CartRepositoryMockAddCartParams {
	mmAddCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddCartParams, len(mmAddCart.callArgs))
	copy(argCopy, mmAddCart.callArgs)

	mmAddCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddCartDone returns true if the count of the AddCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddCartDone() bool {
	if m.AddCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCartMock.invocationsDone()
}

// MinimockAddCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddCartInspect() {
	for _, e := range m.AddCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCartCounter := mm_atomic.LoadUint64(&m.afterAddCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCartMock.defaultExpectation != nil && afterAddCartCounter < 1 {
		if m.AddCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddCart at\n%s", m.AddCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddCart at\n%s with params: %#v", m.AddCartMock.defaultExpectation.expectationOrigins.origin, *m.AddCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCart != nil && afterAddCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddCart at\n%s", m.funcAddCartOrigin)
	}

	if !m.AddCartMock.invocationsDone() && afterAddCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCartMock.expectedInvocations), m.AddCartMock.expectedInvocationsOrigin, afterAddCartCounter)
	}
}

type mCartRepositoryMockClearCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockClearCartParams
	paramPtrs          *CartRepositoryMockClearCartParamPtrs
	expectationOrigins CartRepositoryMockClearCartExpectationOrigins
	results            *CartRepositoryMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockClearCartParams contains parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	userID int64
}

// CartRepositoryMockClearCartParamPtrs contains pointers to parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParamPtrs struct {
	userID *int64
}

// CartRepositoryMockClearCartResults contains results of the CartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// CartRepositoryMockClearCartOrigins contains origins of expectations of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartRepositoryMockClearCart) Optional() *mCartRepositoryMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(userID int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{userID}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userID = &userID
	mmClearCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(userID int64)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the CartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(userID int64) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the CartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(userID int64) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &CartRepositoryMockClearCartParams{userID},
		expectationOrigins: CartRepositoryMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.ClearCart should be invoked
func (mmClearCart *mCartRepositoryMockClearCart) Times(n uint64) *mCartRepositoryMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mCartRepositoryMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements mm_repository.CartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(userID int64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(userID)
	}

	mm_params := CartRepositoryMockClearCartParams{userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v", userID)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	userID int64
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	userID *int64
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	ia1 []model.ItemCart
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{userID}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID
	mmGetCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(userID int64)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(ia1 []model.ItemCart, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{ia1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(userID int64) (ia1 []model.ItemCart, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(userID int64) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{userID},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(ia1 []model.ItemCart, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{ia1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_repository.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(userID int64) (ia1 []model.ItemCart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(userID)
	}

	mm_params := CartRepositoryMockGetCartParams{userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v", userID)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

type mCartRepositoryMockRemoveCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveCartExpectation
	expectations       []*CartRepositoryMockRemoveCartExpectation

	callArgs []*CartRepositoryMockRemoveCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveCartExpectation specifies expectation struct of the CartRepository.RemoveCart
type CartRepositoryMockRemoveCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveCartParams
	paramPtrs          *CartRepositoryMockRemoveCartParamPtrs
	expectationOrigins CartRepositoryMockRemoveCartExpectationOrigins
	results            *CartRepositoryMockRemoveCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveCartParams contains parameters of the CartRepository.RemoveCart
type CartRepositoryMockRemoveCartParams struct {
	userID int64
	sku    uint32
}

// CartRepositoryMockRemoveCartParamPtrs contains pointers to parameters of the CartRepository.RemoveCart
type CartRepositoryMockRemoveCartParamPtrs struct {
	userID *int64
	sku    *uint32
}

// CartRepositoryMockRemoveCartResults contains results of the CartRepository.RemoveCart
type CartRepositoryMockRemoveCartResults struct {
	err error
}

// CartRepositoryMockRemoveCartOrigins contains origins of expectations of the CartRepository.RemoveCart
type CartRepositoryMockRemoveCartExpectationOrigins struct {
	origin       string
	originUserID string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Optional() *mCartRepositoryMockRemoveCart {
	mmRemoveCart.optional = true
	return mmRemoveCart
}

// Expect sets up expected params for CartRepository.RemoveCart
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Expect(userID int64, sku uint32) *mCartRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &CartRepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.paramPtrs != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by ExpectParams functions")
	}

	mmRemoveCart.defaultExpectation.params = &CartRepositoryMockRemoveCartParams{userID, sku}
	mmRemoveCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveCart.expectations {
		if minimock.Equal(e.params, mmRemoveCart.defaultExpectation.params) {
			mmRemoveCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveCart.defaultExpectation.params)
		}
	}

	return mmRemoveCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.RemoveCart
func (mmRemoveCart *mCartRepositoryMockRemoveCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &CartRepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.params != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Expect")
	}

	if mmRemoveCart.defaultExpectation.paramPtrs == nil {
		mmRemoveCart.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveCartParamPtrs{}
	}
	mmRemoveCart.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveCart
}

// ExpectSkuParam2 sets up expected param sku for CartRepository.RemoveCart
func (mmRemoveCart *mCartRepositoryMockRemoveCart) ExpectSkuParam2(sku uint32) *mCartRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &CartRepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.params != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Expect")
	}

	if mmRemoveCart.defaultExpectation.paramPtrs == nil {
		mmRemoveCart.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveCartParamPtrs{}
	}
	mmRemoveCart.defaultExpectation.paramPtrs.sku = &sku
	mmRemoveCart.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRemoveCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveCart
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Inspect(f func(userID int64, sku uint32)) *mCartRepositoryMockRemoveCart {
	if mmRemoveCart.mock.inspectFuncRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveCart")
	}

	mmRemoveCart.mock.inspectFuncRemoveCart = f

	return mmRemoveCart
}

// Return sets up results that will be returned by CartRepository.RemoveCart
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Return(err error) *CartRepositoryMock {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &CartRepositoryMockRemoveCartExpectation{mock: mmRemoveCart.mock}
	}
	mmRemoveCart.defaultExpectation.results = &CartRepositoryMockRemoveCartResults{err}
	mmRemoveCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveCart.mock
}

// Set uses given function f to mock the CartRepository.RemoveCart method
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Set(f func(userID int64, sku uint32) (err error)) *CartRepositoryMock {
	if mmRemoveCart.defaultExpectation != nil {
		mmRemoveCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveCart method")
	}

	if len(mmRemoveCart.expectations) > 0 {
		mmRemoveCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveCart method")
	}

	mmRemoveCart.mock.funcRemoveCart = f
	mmRemoveCart.mock.funcRemoveCartOrigin = minimock.CallerInfo(1)
	return mmRemoveCart.mock
}

// When sets expectation for the CartRepository.RemoveCart which will trigger the result defined by the following
// Then helper
func (mmRemoveCart *mCartRepositoryMockRemoveCart) When(userID int64, sku uint32) *CartRepositoryMockRemoveCartExpectation {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("CartRepositoryMock.RemoveCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveCartExpectation{
		mock:               mmRemoveCart.mock,
		params:             &CartRepositoryMockRemoveCartParams{userID, sku},
		expectationOrigins: CartRepositoryMockRemoveCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveCart.expectations = append(mmRemoveCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveCart should be invoked
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Times(n uint64) *mCartRepositoryMockRemoveCart {
	if n == 0 {
		mmRemoveCart.mock.t.Fatalf("Times of CartRepositoryMock.RemoveCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveCart.expectedInvocations, n)
	mmRemoveCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveCart
}

func (mmRemoveCart *mCartRepositoryMockRemoveCart) invocationsDone() bool {
	if len(mmRemoveCart.expectations) == 0 && mmRemoveCart.defaultExpectation == nil && mmRemoveCart.mock.funcRemoveCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveCart.mock.afterRemoveCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveCart implements mm_repository.CartRepository
func (mmRemoveCart *CartRepositoryMock) RemoveCart(userID int64, sku uint32) (err error) {
	mm_atomic.AddUint64(&mmRemoveCart.beforeRemoveCartCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveCart.afterRemoveCartCounter, 1)

	mmRemoveCart.t.Helper()

	if mmRemoveCart.inspectFuncRemoveCart != nil {
		mmRemoveCart.inspectFuncRemoveCart(userID, sku)
	}

	mm_params := CartRepositoryMockRemoveCartParams{userID, sku}

	// Record call args
	mmRemoveCart.RemoveCartMock.mutex.Lock()
	mmRemoveCart.RemoveCartMock.callArgs = append(mmRemoveCart.RemoveCartMock.callArgs, &mm_params)
	mmRemoveCart.RemoveCartMock.mutex.Unlock()

	for _, e := range mmRemoveCart.RemoveCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveCart.RemoveCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveCart.RemoveCartMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveCart.RemoveCartMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveCart.RemoveCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveCartParams{userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveCart.t.Errorf("CartRepositoryMock.RemoveCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCart.RemoveCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRemoveCart.t.Errorf("CartRepositoryMock.RemoveCart got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCart.RemoveCartMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveCart.t.Errorf("CartRepositoryMock.RemoveCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveCart.RemoveCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveCart.RemoveCartMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveCart.t.Fatal("No results are set for the CartRepositoryMock.RemoveCart")
		}
		return (*mm_results).err
	}
	if mmRemoveCart.funcRemoveCart != nil {
		return mmRemoveCart.funcRemoveCart(userID, sku)
	}
	mmRemoveCart.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveCart. %v %v", userID, sku)
	return
}

// RemoveCartAfterCounter returns a count of finished CartRepositoryMock.RemoveCart invocations
func (mmRemoveCart *CartRepositoryMock) RemoveCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCart.afterRemoveCartCounter)
}

// RemoveCartBeforeCounter returns a count of CartRepositoryMock.RemoveCart invocations
func (mmRemoveCart *CartRepositoryMock) RemoveCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCart.beforeRemoveCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveCart *mCartRepositoryMockRemoveCart) Calls() []*CartRepositoryMockRemoveCartParams {
	mmRemoveCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveCartParams, len(mmRemoveCart.callArgs))
	copy(argCopy, mmRemoveCart.callArgs)

	mmRemoveCart.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveCartDone returns true if the count of the RemoveCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveCartDone() bool {
	if m.RemoveCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveCartMock.invocationsDone()
}

// MinimockRemoveCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveCartInspect() {
	for _, e := range m.RemoveCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCartCounter := mm_atomic.LoadUint64(&m.afterRemoveCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveCartMock.defaultExpectation != nil && afterRemoveCartCounter < 1 {
		if m.RemoveCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveCart at\n%s", m.RemoveCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveCart at\n%s with params: %#v", m.RemoveCartMock.defaultExpectation.expectationOrigins.origin, *m.RemoveCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveCart != nil && afterRemoveCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveCart at\n%s", m.funcRemoveCartOrigin)
	}

	if !m.RemoveCartMock.invocationsDone() && afterRemoveCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveCartMock.expectedInvocations), m.RemoveCartMock.expectedInvocationsOrigin, afterRemoveCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCartInspect()

			m.MinimockClearCartInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCartDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveCartDone()
}
